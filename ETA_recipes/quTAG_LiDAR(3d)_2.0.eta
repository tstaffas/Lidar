{"dpp_template_code":"#------IMPORTS-----\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nfrom matplotlib.widgets import Button\r\nfrom pathlib import Path\r\nimport etabackend.tk.utils as etautils\r\nimport os\r\n\r\nfrom numpy import inf\r\nimport scipy.signal\r\nimport time as t\r\nfrom scipy.signal import chirp, find_peaks, peak_widths\r\nfrom scipy.optimize import curve_fit\r\n\r\nimport lmfit as lm\r\nimport matplotlib.pyplot as plt\r\nfrom lmfit.models import GaussianModel, ConstantModel, SkewedGaussianModel\r\nfrom lmfit import Parameters\r\nfrom colour import Color\r\nfrom matplotlib import cm\r\nimport matplotlib.cm as cmx\r\nfrom mpl_toolkits.mplot3d import Axes3D\r\n\r\nimport random\r\n\r\nimport warnings\r\nwarnings.simplefilter('ignore', np.RankWarning)\r\n\r\n\r\n\r\nSTART = t.time()\r\n#---File handling---\r\nfile = Path(file)\r\n\r\n#------ETA PROCESSING-----\r\ncutfile = eta.clips(file)\r\nresult = eta.run({\"timetagger1\":cutfile}, group='quTAG')\r\nhistogram=result[ch_sel]\r\n#h1=np.loadtxt(\"C:\\PathToFile\\result.txt\") #use this line instead of the previous 3 lines (ETA PROCESSING) if you want to load a reviously saved file for plotting\r\n#np.savetxt(\"C:\\Users\\marti\\OneDrive\\Skrivbord\\Work 2020\\ETAmeasurements\\image\\test.txt\",h1) #use this line instead of plotting if you want to save the analysis result to a file\r\n\r\ndimX = int(float(dimX))\r\ndimY = int(float(dimY))\r\nbinsize = int(float(binsize))\r\nbins = int(float(bins))\r\n\r\n#------- Functions to calculate 3D data ----------\r\n\r\ndef calcDistance(t_ref,t_signal):\r\n    #calculates the distance between times, times are given in picoseconds and result is given in mm\r\n    return 1000*0.5*(t_signal-t_ref)*(10**(-12))*299792458\r\n\r\ndef getDistance(ref_peak, histogram):\r\n    return calcDistance(binsize*ref_peak, binsize*np.where(histogram == np.amax(histogram))[0][0])\r\n\r\n\r\ndef XYZ(r,thetaX,thetaY):\r\n    #converts the distance data and angle information to cartesian coordinates\r\n\r\n    z = r/(np.sqrt(1+np.tan(thetaX)**2+np.tan(thetaY)**2))\r\n    y = z*np.tan(thetaY)\r\n    x = z*np.tan(thetaX)\r\n\r\n    return x,y,z\r\n\r\ndef angles(rect,dimX,dimY):\r\n    #rect = [x_max,y_max, x_min, y_min]\r\n    #Calculates the angles of the mirrors as a function of the supplied x_voltages  (Should depend on the initial position, should be checked)\r\n\r\n    x_voltages = np.linspace(int(float(rect[0])),int(float(rect[2])),dimX)\r\n    y_voltages = np.linspace(int(float(rect[1])),int(float(rect[3])),dimY)\r\n    \r\n    x_deg = x_voltages * 2.5 * np.pi / 180   \r\n    y_deg = y_voltages * 2.5 * np.pi / 180 #OBS: minus sign on y might be a relic/pr needed. Check images against reality\r\n\r\n    return x_deg, y_deg\r\n\r\n\r\n################## Functions for plotting and saving data ##############################\r\ndef scatter(d_data, I_data, file, cutoff, name = \"\",save = True):\r\n    #Produces a 3d scatterplot of the generated data\r\n    Xdata , Ydata, Zdata = [], [], []\r\n    for p in d_data:\r\n        if I_data[p] > 5: #Filters out noise from the image\r\n            x,y,z = XYZ(d_data[p],p[0],p[1])\r\n            Xdata.append(x)\r\n            Ydata.append(y)\r\n            Zdata.append(z)\r\n        \r\n    fig = plt.figure(figsize=(15,15))\r\n    ax = fig.add_subplot(111,projection=\"3d\")\r\n\r\n    #### Colour scheme #####\r\n    C = {\"#4568DC\" : \"#B06AB3\"#(blue to purple)  \r\n        ,\"#C33764\" : \"#1D2671\" #(pink to blue)\r\n        ,\"#00F260\" : \"#0575E6\" #(green to blue) \r\n        ,\"#bc4e9c\" : \"#f80759\" #(purple to pink)\r\n        ,\"#333333\" : \"#dd1818\" # (dark to red) \r\n        ,\"#009FFF\" : \"#ec2F4B\" #(blue to red)\r\n        ,\"#654ea3\" : \"#eaafc8\" #(ultraviolet)\r\n        ,\"#a8ff78\" : \"#78ffd6\" #can't remember)\r\n        ,\"#005AA7\" : \"#FFFDE4\" #(blue to white)\r\n        ,\"#0bf91f\" : \"#ff002c\" #(green to red)\r\n        }\r\n    \r\n    range = len(Zdata)\r\n    key = random.choice(list(C.keys()))\r\n    key = \"#0bf91f\"\r\n    primer = Color(key)\r\n    base = Color(C[key])\r\n    colors = list(primer.range_to(base, range ))\r\n    \r\n    zmin = np.min(Zdata)\r\n    zmax = np.max(Zdata)\r\n\r\n    zcol = np.round( (Zdata-zmin) / (zmax-zmin) * range - 1)\r\n    col = []\r\n\r\n    for num in zcol:\r\n        col += [colors[int(num)].rgb]\r\n    \r\n    ##### Cleaning some of the data to avoid squished plots ####\r\n    avg = np.mean([x for x in Zdata if not np.isnan(x)])\r\n    std = np.std([x for x in Zdata if not np.isnan(x)])\r\n\r\n    Zdata = [x if x > avg-cutoff*std and x < avg+cutoff*std else np.NaN for x in Zdata ]\r\n    \r\n    ax.scatter(Ydata,Zdata,Xdata, c = col ,s=2) #Plots the data\r\n    #ax.azim = int(z_rot)\r\n    #ax.elev = int(x_rot)\r\n    \r\n    #ax.set_title(\"3D reconstruction\", fontsize = 40)\r\n    ax.set_xlabel(\"mm\", fontsize = 40, labelpad=40)\r\n    ax.set_ylabel(\"mm\", fontsize = 40, labelpad=40)\r\n    ax.set_zlabel(\"mm\", fontsize = 40, labelpad=40)\r\n    \r\n    ax.tick_params(labelsize=30)\r\n    \r\n    #Saves the data\r\n    if save: #Do you want to save the picture\r\n        if not os.path.exists(file.parent.joinpath(f'analyzed')): #If folder does not exist, create it\r\n            os.makedirs(file.parent.joinpath(f'analyzed'))\r\n        \r\n        #Code block generates a new name for the image in order to not save over old results        \r\n        folder = str(file.parent.joinpath(f'analyzed'))\r\n        filename = name+file.stem+'_3Dplot.png'\r\n        directory = os.fsencode(folder)\r\n        FILES = [os.fsdecode(f) for f in os.listdir(directory)]\r\n        i = 2\r\n        while str(filename) in FILES:\r\n            filename = name+file.stem+'_3Dplot_' +str(i)+  '.png'\r\n            i+=1\r\n            \r\n        \r\n        savepath = file.parent.joinpath(f'analyzed', filename)\r\n        fig.savefig(savepath) # needs path\r\n    \r\n    plt.close('all')\r\n\r\n \r\ndef save_pixel(histogram,file,x,y):\r\n    #Saves a single pixel (x,y) to be used for trouble shooting and diagnosing\r\n    \r\n    if not os.path.exists(file.parent.joinpath(f'analyzed pixels')):\r\n        os.makedirs(file.parent.joinpath(f'analyzed pixels'))\r\n    \r\n    savepath = file.parent.joinpath(f'analyzed pixels', f'pixel_x={x}_y={y}.txt')\r\n    np.savetxt(savepath,np.transpose([np.arange(0,histogram[x][y].size)*binsize,histogram[x][y]]))\r\n\r\ndef save_pixel_array(histogram,file):\r\n    #Saves several pixels for diagnosing and trouble shooting the algorithm\r\n    \r\n    for i in range (9):\r\n        x = random.randint(0,dimX-1)\r\n        y = random.randint(0,dimY-1)\r\n        \r\n        save_pixel(histogram,file,x,y)\r\n    \r\ndef save_data(d_data, file, name, I_data = None):\r\n    \r\n    thetaX , thetaY, D, I = [], [], [], []\r\n    for p in d_data:\r\n        thetaX.append(p[0])\r\n        thetaY.append(p[1])\r\n        D.append(d_data[p])\r\n        I.append(I_data[p])\r\n        \r\n        \"\"\"\r\n        x,y,z = p[0], p[1], d_data[p]\r\n        Xdata.append(x)\r\n        Ydata.append(y)\r\n        Zdata.append(z)\r\n        if I_data != None:\r\n            I.append(I_data[(x,y,z)])\r\n        \"\"\"\r\n        \r\n    #Saves the data\r\n    if not os.path.exists(file.parent.joinpath(f'3d data')): #If folder does not exist, create it\r\n        os.makedirs(file.parent.joinpath(f'3d data'))\r\n    \r\n    filename = name+file.stem\r\n    if I_data != None:\r\n        savepath = file.parent.joinpath(f'3d data', filename+\" intensity\")\r\n        np.savetxt(savepath,np.transpose([thetaX,thetaY,D,I]))\r\n    else:\r\n        savepath = file.parent.joinpath(f'3d data', filename)\r\n        np.savetxt(savepath,np.transpose([Xdata,Ydata,Zdata]))\r\n    \r\n########################## Functions to fit plots to data ##################################3\r\ndef gauss(x,y,ref):\r\n    #Fits a Gaussian curve to the data\r\n\r\n    #Guesses for start parameters\r\n    supermodel = ConstantModel()+GaussianModel() #The constant model is neded to decrease sensitivity to background noise\r\n    a_peak = np.max(y)\r\n    t_peak = np.where(y == a_peak)[0][0]*binsize\r\n    avg = np.mean(y)\r\n    params = supermodel.make_params(amplitude=a_peak*(22*np.sqrt(2*np.pi)), center=t_peak, sigma=22, c=3)\r\n    \r\n    result = supermodel.fit(y, params=params, x=x)\r\n    center = result.params['center'].value\r\n    height = result.params['amplitude'].value\r\n    return calcDistance(center,ref*binsize), height\r\n\r\ndef skewedgauss(x,y, ref):\r\n    #Fits a SkewedGaussian function to the data\r\n    #Acheives slightly better result on individual pixels but overal performance is worse, not sure why. Probably due to higher sensitivity\r\n    \r\n    supermodel = ConstantModel() + SkewedGaussianModel() #The constant model is neded to decrease sensitivity to background noise\r\n    \r\n    # Start guesses for parameters\r\n    a_peak = np.max(y)\r\n    t_peak = np.where(y == a_peak)[0][0]*binsize\r\n    avg = np.mean(y)\r\n    gamma = 1.5\r\n    sigma = 30\r\n\r\n    params = supermodel.make_params(amplitude = a_peak*sigma*np.sqrt(2*np.pi),\r\n                                    center = t_peak,\r\n                                    sigma = sigma,\r\n                                    gamma = gamma,\r\n                                    c = 3)\r\n\r\n    result = supermodel.fit(y, params = params, x = x)\r\n    center = result.params['center'].value\r\n    return calcDistance(center,ref*binsize)\r\n    \r\n    \r\n#----------------- Scan variables ---------------------\r\nrect = rect.strip('][').split(',')\r\nx_deg, y_deg = angles(rect,dimX,dimY)\r\n\r\n#------------- Run Variables ---------------------\r\nref = int(index_ref) # Reference peak close to Galvo. (for 780x16)\r\nbackground_cutoff = int(index_cutoff) # Index where background reflections are gone.(for 780x16)\r\ntime = (np.arange(0,histogram[0][0].size)*binsize)\r\n\r\n\r\n#--------------- Computational analysis -----------\r\ndef analyse(histogram):\r\n    d_data = {}\r\n    average_peak = 0\r\n    average_failed_peak = 0\r\n    I_data = {}\r\n    \r\n    F = 0   #Used to keep track of the number of failed pixels\r\n    start = t.time()\r\n    for i in range(0,len(y_deg)):\r\n        print(i,\"/\",len(y_deg))\r\n        for j in range(0,len(x_deg)):\r\n            h = histogram[j][i]\r\n            h[:background_cutoff] = 0\r\n            peak = np.amax(h)\r\n            \r\n            #dFit, height = gauss(time,h,ref)\r\n            #dFit = skewedgauss(time,h,ref)\r\n            dFit = getDistance(ref, h)\r\n            \r\n            d_data[(x_deg[i],y_deg[j])] = dFit\r\n            I_data[(x_deg[i],y_deg[j])] = peak\r\n            \r\n            if peak < 5:\r\n                F += 1\r\n                average_failed_peak += peak\r\n            else:\r\n                average_peak += peak\r\n            \r\n            \"\"\"\r\n            if peak > 5:  #removes pixels with only noise, noise threshold can be modified\r\n                #dFit, height = gauss(time,h,ref)\r\n                #dFit = skewedgauss(time,h,ref)\r\n                dFit = getDistance(ref, h)\r\n                \r\n                if dFit != np.NaN:\r\n                    xf,yf,zf = XYZ(np.abs(dFit),x_deg[i],y_deg[j])\r\n                    \r\n                    d_data[(xf,yf)] = zf\r\n                    I_data[(xf,yf,zf)] = peak\r\n                \r\n                average_peak += peak \r\n            else:\r\n                F +=1\r\n                average_failed_peak += peak\r\n            \"\"\"\r\n\r\n    stop = t.time()\r\n    print(\"Analysis time: \", stop-start)\r\n    print(\"Failed pixels: \", F)\r\n    print(\"Average peak: \", average_peak/(dimY*dimX - F))\r\n    \r\n    if F != 0:\r\n        print(\"Average failed peak: \", average_failed_peak/F)\r\n    \r\n    return d_data, I_data\r\n    \r\n#save_pixel_array(histogram, file)\r\nd_data, I_data = analyse(histogram)\r\nprint(\"Total Analysis time: \", t.time()-START)\r\n#-------------------- Save code -------------\r\nprint(\"Saving Images\")\r\ncoff = int(coff) # prevents the images from being to squished\r\n\r\n\r\nscatter(d_data, I_data, file, coff,save_name+\"_Fit_\")\r\nsave_data(d_data, file, save_name + '_', I_data)\r\n\r\n\r\nprint(\"Job Done!\")","eta_index_table":"[{\"id\":\"var_templatejkim3bkj\",\"name\":\"file\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"C:/Users/staff/Documents/Lidar LF/Data/210330/apple_1310nm_100ms_[8,8,-8,-8]_80MHz_100x100_210330.timeres\"},{\"id\":\"var_templatekl6exoyq\",\"name\":\"save_name\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"peak\"},{\"id\":\"var_templatejkim48wp\",\"name\":\"binsize\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"16\"},{\"id\":\"var_templatejkim2z6x\",\"name\":\"bins\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"780\"},{\"id\":\"var_templatejkim6uch\",\"name\":\"expname\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"3D\"},{\"id\":\"var_templatejks89alb\",\"name\":\"ch_sel\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"t1\"},{\"id\":\"var_templatek1wj6afv\",\"name\":\"records_per_cut\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"2e5\"},{\"id\":\"var_templatek8k93yir\",\"name\":\"delay\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"0\"},{\"id\":\"var_templatek8k9432h\",\"name\":\"fw_delay\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"0\"},{\"id\":\"var_templatek8k94746\",\"name\":\"bw_delay\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"0\"},{\"id\":\"var_templatekl81i2po\",\"name\":\"sync_delay\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"0\"},{\"id\":\"var_templatekippt2ni\",\"name\":\"rect\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"[8,8,-8,-8]\"},{\"id\":\"var_templatekipptn7c\",\"name\":\"dimX\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"100\"},{\"id\":\"var_templatekiq1qw9x\",\"name\":\"dimY\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"100\"},{\"id\":\"var_templatekippu799\",\"name\":\"index_ref\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"175\"},{\"id\":\"var_templatekir5s2pd\",\"name\":\"index_cutoff\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"175\"},{\"id\":\"var_templatekl83xm66\",\"name\":\"z_rot\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"270\"},{\"id\":\"var_templatekl85yl1r\",\"name\":\"x_rot\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"20\"},{\"id\":\"var_templatekmvv0jz2\",\"name\":\"coff\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"1\"},{\"id\":\"dpp_template_code\",\"name\":\"display\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"\"},{\"id\":\"vi_templatejks7yt8a\",\"name\":\"delay1-8\",\"group\":\"quTAG\",\"info\":\"游닌[1] 游닋[8] \",\"config\":\"\"},{\"id\":\"vi_templatekkzm437v\",\"name\":\"delay2-9\",\"group\":\"quTAG\",\"info\":\"游닌[2] 游닋[9] \",\"config\":\"\"},{\"id\":\"vi_templatejhrlupxy\",\"name\":\"delay5-10\",\"group\":\"quTAG\",\"info\":\"游닌[5] 游닋[10] \",\"config\":\"\"},{\"id\":\"vi_templatejhrlp8yt\",\"name\":\"lifetime (start=ch5, stop=ch8)[t1]\",\"group\":\"quTAG\",\"info\":\"游닌[10, 8, 102, 103] \",\"config\":\"\"},{\"id\":\"vi_templatekbz00gz5\",\"name\":\"lifetime (start=ch5, stop=ch9)[t2]\",\"group\":\"quTAG\",\"info\":\"游닌[5, 9] \",\"config\":\"\"},{\"id\":\"vi_templatekbz03aiq\",\"name\":\"lifetime (start=ch8, stop=ch9)[t3]\",\"group\":\"quTAG\",\"info\":\"游닌[8, 9] \",\"config\":\"\"},{\"id\":\"vi_templatek6z86r0w\",\"name\":\"Time Tagger\",\"group\":\"quTAG\",\"info\":\"游닆[0, 1, 2, 3, 4, 5] \",\"config\":\"\"}]","vi_templatejhrlp8yt":"{\"nodes\":[{\"x\":145,\"y\":157,\"fixed\":true,\"initial\":true,\"text\":\"stopped\",\"marked\":true},{\"x\":366,\"y\":164,\"fixed\":true,\"text\":\"started\",\"marked\":true,\"px\":366,\"py\":164},{\"x\":367,\"y\":321,\"weight\":1,\"fixed\":true,\"text\":\"Moving\",\"px\":367,\"py\":321},{\"x\":502,\"y\":319,\"weight\":1,\"fixed\":true,\"text\":\"Done\",\"px\":502,\"py\":319}],\"edges\":[{\"source\":0,\"target\":1,\"text\":\"10\"},{\"source\":1,\"target\":0,\"text\":\"8\"},{\"source\":1,\"target\":1,\"text\":\"10\"},{\"source\":1,\"target\":2,\"text\":\"102\"},{\"source\":2,\"target\":3,\"text\":\"102\"},{\"source\":2,\"target\":1,\"text\":\"103\"},{\"source\":0,\"target\":2,\"text\":\"102\"}],\"usercode\":\"CLOCK(c1)\\nINTEGER(X)\\nINTEGER(Y)\\nINTEGER(pixelnumber)\\nHISTOGRAM(t1, (`bins`, `binsize`), [`dimX`,`dimY`])\\n\\nMoving--103-->started:\\n    {\\n        pixelnumber+=1\\n        #print(X)\\n        #print(Y)\\n        x_counter_fwd = pixelnumber % `dimX`\\n        x_counter_bwd = `dimX`-x_counter_fwd-1\\n        Y = int(np.floor(pixelnumber / `dimX`))\\n        X = x_counter_fwd if Y%2 == 0 else x_counter_bwd\\n        conditional = int(pixelnumber == int(`dimX`)*int(`dimX`)+1)\\n    }\\n    \\nstopped:\\n    c1.stop()\\n    t1[X][Y].record(c1)\\n    \\nstarted:\\n    c1.start()\\n    \\nDone:\\n    abort()\"}","vi_templatejhrlupxy":"{\"nodes\":[{\"x\":141,\"y\":129,\"fixed\":true,\"initial\":true,\"text\":\"a\"}],\"edges\":[{\"source\":0,\"target\":0,\"text\":\"5\"}],\"usercode\":\"a:\\n    emit(10,`sync_delay`)# here, ch2 is duplicated to ch9 with a delay of bw_delay ps\"}","var_templatejkim2z6x":null,"var_templatejkim3bkj":null,"var_templatejkim48wp":null,"var_templatejkim6uch":null,"vi_templatejks7yt8a":"{\"nodes\":[{\"x\":141,\"y\":129,\"fixed\":true,\"initial\":true,\"text\":\"a\"}],\"edges\":[{\"source\":0,\"target\":0,\"text\":\"1\"}],\"usercode\":\"a:\\n    emit(8,`fw_delay`) # here, ch1 is duplicated to ch8 with a delay of fw_delay ps\"}","var_templatejks89alb":null,"var_templatek1wj6afv":null,"vi_templatek6z86r0w":"{\"nodes\":[{\"x\":135,\"y\":77,\"fixed\":true,\"initial\":true,\"px\":135,\"py\":77}],\"edges\":[],\"usercode\":\"RFILE(timetagger1,[0,1,2,3,4,5])\"}","var_templatek8k93yir":null,"var_templatek8k9432h":null,"var_templatek8k94746":null,"vi_templatekbz00gz5":"{\"nodes\":[{\"x\":145,\"y\":157,\"fixed\":true,\"initial\":true,\"text\":\"stopped\",\"marked\":true},{\"x\":366,\"y\":174,\"fixed\":true,\"text\":\"started\",\"marked\":true}],\"edges\":[{\"source\":0,\"target\":1,\"text\":\"5\"},{\"source\":1,\"target\":0,\"text\":\"9\"},{\"source\":1,\"target\":1,\"text\":\"5\"}],\"usercode\":\"CLOCK(c2)\\nHISTOGRAM(t2,(`bins`,`binsize`))\\n\\nstarted:\\n    c2.start()\\nstopped:\\n    c2.stop()\\n    t2.record(c2)\"}","vi_templatekbz03aiq":"{\"nodes\":[{\"x\":145,\"y\":157,\"fixed\":true,\"initial\":true,\"text\":\"stopped\",\"marked\":true},{\"x\":366,\"y\":174,\"fixed\":true,\"text\":\"started\",\"marked\":true}],\"edges\":[{\"source\":0,\"target\":1,\"text\":\"8\"},{\"source\":1,\"target\":0,\"text\":\"9\"},{\"source\":1,\"target\":1,\"text\":\"8\"}],\"usercode\":\"CLOCK(c3)\\nHISTOGRAM(t3,(`bins`,`binsize`))\\n\\nstarted:\\n    c3.start()\\nstopped:\\n    c3.stop()\\n    t3.record(c3)\"}","var_templatekippt2ni":null,"var_templatekipptn7c":null,"var_templatekippu799":null,"var_templatekiq1qw9x":null,"var_templatekir5s2pd":null,"vi_templatekkzm437v":"{\"nodes\":[{\"x\":141,\"y\":129,\"fixed\":true,\"initial\":true,\"text\":\"a\"}],\"edges\":[{\"source\":0,\"target\":0,\"text\":\"2\"}],\"usercode\":\"a:\\n    emit(9,`bw_delay`)# here, ch2 is duplicated to ch9 with a delay of bw_delay ps\"}","var_templatekl6exoyq":null,"var_templatekl81i2po":null,"var_templatekl83xm66":null,"var_templatekl85yl1r":null,"var_templatekmvv0jz2":null}