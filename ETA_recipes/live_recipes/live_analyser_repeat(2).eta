{"dpp_template_code":"import pathlib\nimport logging\n\nimport numpy as np\nimport matplotlib\nmatplotlib.use('TkAgg')\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\n\nfrom bokeh.application import Application\nfrom bokeh.application.handlers.function import FunctionHandler\nimport etabackend.tk as etatk\n\nfrom colour import Color\nfrom matplotlib import cm\nimport matplotlib.cm as cmx\nimport os\n\nimport random\nimport time\nimport queue\n\nlogger = logging.getLogger('etabackend.frontend')\n\nlogger.info(\"ETA lifetime (realtime) is started.\")\n\nrecords_per_cut = int(float(records_per_cut)) if records_per_cut != \"\" else None\n\nSIMULATE_GROWTH = False\nDATAFOLDER = 'analyzed data'\nLABEL = 'lifetime'\n\nbinsize = int(float(binsize))\nbins = int(float(bins))\nbin_factor = int(float(binsize))\nfile = pathlib.Path(file)\n\nindex_cutoff = int(index_cutoff)\nindex_ref = int(index_ref)\n\n#------ADJUST DELAY-----\ndelay = int(float(delay))\neta.recipe.set_parameter(\"sync_delay\", str(sync_delay))\neta.recipe.set_parameter(\"bw_delay\",str(max(0,-1*delay)))\neta.recipe.set_parameter(\"fw_delay\",str(max(0,delay)))\neta.load_recipe()\n\n#------Evaluate Data-----\nclass LifetimeResult(etatk.data.ETAResult):\n    def calculate_result(self, result):\n        fullhist=result[ch_sel]\n        xdata = np.arange(fullhist.size) * bin_factor\n        ydata = fullhist\n        return xdata, ydata\n        \ndef calcDistance(t_ref,t_signal):\n    #calculates the distance between times, times are given in picoseconds and result is given in mm\n    return 1000*0.5*(t_signal-t_ref)*(10**(-12))*299792458\n\ndef getDistance(ref_peak, histogram):\n    return calcDistance(binsize*ref_peak, binsize*np.where(histogram == np.amax(histogram))[0][0])\n    \ndef XYZ(r,thetaX,thetaY):\n    #converts the distance data and angle information to cartesian coordinates\n    \n    z = r/(np.sqrt(1+np.tan(thetaX)**2+np.tan(thetaY)**2))\n    y = z*np.tan(thetaY)\n    x = z*np.tan(thetaX)\n    \ndef angles(rect,dimX,dimY):\n    #rect = [x_max,y_max, x_min, y_min]\n    #Calculates the angles of the mirrors as a function of the supplied x_voltages  (Should depend on the initial position, should be checked)\n\n    x_voltages = np.linspace(int(float(rect[0])),int(float(rect[2])),dimX)\n    y_voltages = np.linspace(int(float(rect[1])),int(float(rect[3])),dimY)\n    \n    x_deg = x_voltages * 2.5 * np.pi / 180   \n    y_deg = y_voltages * 2.5 * np.pi / 180 #OBS: minus sign on y might be a relic/pr needed. Check images against reality\n\n    return x_deg, y_deg\n\ndef XYZ(r,thetaX,thetaY):\n    #converts the distance data and angle information to cartesian coordinates\n\n    z = r/(np.sqrt(1+np.tan(thetaX)**2+np.tan(thetaY)**2))\n    y = z*np.tan(thetaY)\n    x = z*np.tan(thetaX)\n    \n    return x,y,z\n\ndef calcDistance(t1,t2):\n    #calculates the distance between times, times are given in picoseconds and result is given in mm\n    return 1000*0.5*(t2-t1)*(10**(-12))*299792458\n\ndef getDistance(ref_peak, histogram):\n    return calcDistance(binsize*np.where(histogram == np.amax(histogram))[0][0],binsize*ref_peak)\n\ndef save_scatter(data, file, cutoff, name = \"\",save = True):\n    #Produces a 3d scatterplot of the generated data\n    \n    Xdata , Ydata , Zdata = [], [], []\n    \n    for p in data:\n        if data[p] != 0:\n            x,y,z = XYZ(data[p], p[0], p[1])\n            \n            Xdata.append(x)\n            Ydata.append(y)\n            Zdata.append(z) \n        \n    fig = plt.figure(figsize=(15,15))\n    ax = fig.add_subplot(111,projection=\"3d\")\n\n    #### Colour scheme #####\n    zmin = np.min(Zdata)\n    zmax = np.max(Zdata)\n    C = {\"#4568DC\" : \"#B06AB3\"#(blue to purple)  \n        ,\"#C33764\" : \"#1D2671\" #(pink to blue)\n        ,\"#00F260\" : \"#0575E6\" #(green to blue) \n        ,\"#bc4e9c\" : \"#f80759\" #(purple to pink)\n        ,\"#333333\" : \"#dd1818\" # (dark to red) \n        ,\"#009FFF\" : \"#ec2F4B\" #(blue to red)\n        ,\"#654ea3\" : \"#eaafc8\" #(ultraviolet)\n        ,\"#a8ff78\" : \"#78ffd6\" #can't remember)\n        ,\"#005AA7\" : \"#FFFDE4\" #(blue to white) \n        }\n        \n    primer = Color(random.choice(list(C.keys())))\n    colors = list(primer.range_to(Color(primer),1*len(Zdata)))\n\n    zcol = np.round((Zdata-zmin)/(zmax-zmin)*(len(Zdata)) -1)\n    col = []\n\n    for i in range(len(Zdata)):\n        num = zcol[i]\n        col += [colors[int(num)].rgb]\n    \n    ##### Cleaning some of the data to avoid squished plots ####\n    avg = np.mean([x for x in Zdata if not np.isnan(x)])\n    std = np.std([x for x in Zdata if not np.isnan(x)])\n\n    Zdata = [x if x > avg-cutoff*std and x < avg+cutoff*std else np.NaN for x in Zdata ]\n    \n    ax.scatter(Ydata,Zdata,Xdata, c = col ,s=2) #Plots the data\n    \n    #Saves the data\n    if save: #Do you want to save the picture\n        if not os.path.exists(file.parent.joinpath(f'live_analyzed')): #If folder does not exist, create it\n            os.makedirs(file.parent.joinpath(f'live_analyzed'))\n        \n        #Code block generates a new name for the image in order to not save over old results        \n        folder = str(file.parent.joinpath(f'live_analyzed'))\n        filename = name+file.stem+'_3Dplot.png'\n        directory = os.fsencode(folder)\n        FILES = [os.fsdecode(f) for f in os.listdir(directory)]\n        i = 2\n        while str(filename) in FILES:\n            filename = name+file.stem+'_live_3Dplot_' +str(i) +  '.png'\n            i+=1\n            \n        savepath = file.parent.joinpath(f'live_analyzed', filename)\n        fig.savefig(savepath) # needs path\n    \n    plt.close(\"all\")\n\nclass live_analyser:\n    def __init__(self, fig, ax, file, eta_result, voltages = \"[8,8,-8,-8]\", dimX = 100, dimY = 100, ref_peak = 178):\n        self.file = file\n        self.file_size = self.file.stat().st_size\n        self.eta_result = eta_result\n        \n        self.voltages = voltages.strip('][').split(',')\n        self.dimX = int(dimX)\n        self.dimY = int(dimY)\n        \n        self.ref_peak = ref_peak\n        self.x_angles, self.y_angles = angles(self.voltages, dimX, dimY)\n        \n        \n        self.data = {}\n        self.empty = np.zeros(780)\n        self.Xdata, self.Ydata, self.Zdata = [], [], []\n        \n        self.fig, self.ax = fig, ax\n \n    \n    def analyse(self):\n        print(\"\\nANALYSING DATA: \", len(self.data), \"from (x,y): \", self.current_x, self.current_y)\n        \n        self.histogram = self.eta_result.ydata[0]\n        lower_y = self.current_y\n        upper_y = lower_y +10 if lower_y+10 <= self.dimY else self.dimY\n        \n        #print(\"Size: \", self.histogram.shape)\n        \n        failed_pixels = 0\n        for i in range(lower_y,self.dimY):\n            for j in range(0,self.dimX):\n                h = self.histogram[j][i]\n                h[:index_cutoff] = 0\n                \n                peak = np.amax(h)\n                \n                if  peak > 5:\n                    d = calcDistance(binsize*index_ref, binsize*np.where(h == peak)[0][0])\n                    \n                    if d != 0:\n                        self.data[(self.x_angles[i],self.y_angles[j])] = np.abs(d)\n                        \n                    self.current_y = i\n                    self.current_x = j\n                    \n                else:\n                    failed_pixels += 1\n       \n        print(\"Final (i,j): \", i, j, \" # Failed pixels: \", failed_pixels)\n        \n        ##### Extract the data for plotting ####\n        self.Xdata, self.Ydata, self.Zdata = [], [], []\n        for p in self.data:\n            if self.data[p] != 0:\n                x,y,z = XYZ(self.data[p], p[0], p[1])\n            \n                self.Xdata.append(x)\n                self.Ydata.append(y)\n                self.Zdata.append(z)\n        \n        ##### Cleaning some of the data to avoid squished plots ####\n        avg = np.mean([x for x in self.Zdata if not np.isnan(x)])\n        std = np.std([x for x in self.Zdata if not np.isnan(x)])\n        cutoff = 3\n\n        self.Zdata = [x if x > avg-cutoff*std and x < avg+cutoff*std else np.NaN for x in self.Zdata ]\n \n        \n        self.labelx = \"Frame: \" + str(self.frame) + '\\n' + 'Time of anal + plot: ' + str(round(time.time()- self.start_loop, 4) )\n        self.labely = \"#Plotted points: \" + str(len(self.Zdata)) + \"\\n# Data point: \" + str(len(self.data))\n        \n        print(self.labelx, '\\n')\n        print(self.labely, '\\n')\n    \n    def plot(self):\n        self.ax.clear()\n        \n        # ax.scatter(Ydata,Zdata,Xdata, c = col ,s=2) #Plots the data\n        self.ax.scatter(self.Ydata, self.Zdata, self.Xdata, s=2)\n        \n        self.ax.set_xlabel(self.labelx)\n        self.ax.set_ylabel(self.labely)\n        self.fig.canvas.flush_events()\n    \n    def init_figure(self):\n        print(\"\\n INITIALIZING FIGURE\")\n        self.start_loop = time.time()\n        \n        self.current_x = 0\n        self.current_y = 0\n        self.start = time.time()\n        \n        self.analyse()\n        \n    def update(self):\n        self.start_loop = time.time()\n        print('Update called')\n        self.analyse()\n        self.plot()\n        \n    def close(self):\n        save_scatter(self.data, self.file, cutoff = 2, name = \"live_peak_analyzed\",save = True)\n        \n        self.stop = time.time()\n        print(\"Total time elapsed: \", self.stop - self.start)\n        \n    def run(self):\n        self.frame = -1\n        n = 0\n        self.initiated = False\n        self.is_static = False\n        while True:\n            self.frame += 1 \n            if self.frame == 0:\n                self.init_figure()\n                self.initiated = True\n                \n            #print(\"\\n\", \"FILE SIZE: \", self.file.stat().st_size, \"\\n\")\n            \n            if self.file_size == self.file.stat().st_size:\n                self.is_static = True\n                \n            if self.file_size < self.file.stat().st_size - 10*int(records_per_cut) or self.is_static:\n                self.is_static = False\n                self.file_size = self.file.stat().st_size\n                \n                lastupdate = self.eta_result.lastupdate\n                self.eta_result.update()\n                if lastupdate == self.eta_result.lastupdate:\n                    print('Waiting for new data')\n                    n += 1\n                    continue\n            \n                else:\n                    print('New data was available')\n                    n = 0\n                    self.update()\n            \n            else:\n                n += 1\n                \n            time.sleep(float(TPF))\n            \n            if n == 30 and self.initiated: #or self.frame == 30:\n                self.close()\n                break\n            \nresult = LifetimeResult(file, group='quTAG', records_per_cut=records_per_cut, \n                        kernel=eta, timeout=float(0.2), \n                        simulate_growth=SIMULATE_GROWTH)\n\nplt.ion()\nfig = plt.figure()\nax = fig.add_subplot('111', projection = '3d')\n\n#def __init__(self, file, eta_result, fig, ax, voltages = \"[8,8,-8,-8]\", dimX = 100, dimY = 100, ref_peak = 178)\nemp = live_analyser( fig = fig, ax = ax, file = file, eta_result = result, dimX = int(float(dimX)), dimY = int(float(dimY)) )\nemp.run()\n\nlogger.info(\"ETA realtime is stopped.\")\n\n\n","eta_index_table":"[{\"id\":\"var_templatejkim3bkj\",\"name\":\"file\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"C:/Users/vLab/Desktop/Lidar/live_cup_[8,8,-8,-8]100x100.01spp_210311.timeres\"},{\"id\":\"var_templatejkim48wp\",\"name\":\"binsize\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"16\"},{\"id\":\"var_templatejkim2z6x\",\"name\":\"bins\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"780\"},{\"id\":\"var_templatejkim6uch\",\"name\":\"expname\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"Live 3D\"},{\"id\":\"var_templatejks89alb\",\"name\":\"ch_sel\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"t1\"},{\"id\":\"var_templatek1wj6afv\",\"name\":\"records_per_cut\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"6e4\"},{\"id\":\"var_templatek8k93yir\",\"name\":\"delay\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"0\"},{\"id\":\"var_templatek8k9432h\",\"name\":\"fw_delay\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"0\"},{\"id\":\"var_templatek8k94746\",\"name\":\"bw_delay\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"0\"},{\"id\":\"var_templatekl80ywey\",\"name\":\"sync_delay\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"5000\"},{\"id\":\"var_templatekippt2ni\",\"name\":\"square\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"[8,8,-8,-8]\"},{\"id\":\"var_templatekipptn7c\",\"name\":\"dimX\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"100\"},{\"id\":\"var_templatekiq1qw9x\",\"name\":\"dimY\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"100\"},{\"id\":\"var_templatekippu799\",\"name\":\"index_ref\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"175\"},{\"id\":\"var_templatekir5s2pd\",\"name\":\"index_cutoff\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"170\"},{\"id\":\"var_templateklgftl3g\",\"name\":\"TPF\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"0.1\"},{\"id\":\"var_templatekrm0koas\",\"name\":\"repeating\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"0\"},{\"id\":\"dpp_template_code\",\"name\":\"display\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"\"},{\"id\":\"vi_templatejks7yt8a\",\"name\":\"delay1-8\",\"group\":\"quTAG\",\"info\":\"游닌[1] 游닋[8] \",\"config\":\"\"},{\"id\":\"vi_templatekkzm437v\",\"name\":\"delay2-9\",\"group\":\"quTAG\",\"info\":\"游닌[2] 游닋[9] \",\"config\":\"\"},{\"id\":\"vi_templatejhrlupxy\",\"name\":\"delay5-10\",\"group\":\"quTAG\",\"info\":\"游닌[5] 游닋[10] \",\"config\":\"\"},{\"id\":\"vi_templatejhrlp8yt\",\"name\":\"lifetime (start=ch5, stop=ch8)[t1]\",\"group\":\"quTAG\",\"info\":\"游닌[10, 8, 102, 103] \",\"config\":\"\"},{\"id\":\"vi_templatekbz00gz5\",\"name\":\"lifetime (start=ch5, stop=ch9)[t2]\",\"group\":\"quTAG\",\"info\":\"游닌[5, 9] \",\"config\":\"\"},{\"id\":\"vi_templatekbz03aiq\",\"name\":\"lifetime (start=ch8, stop=ch9)[t3]\",\"group\":\"quTAG\",\"info\":\"游닌[8, 9] \",\"config\":\"\"},{\"id\":\"vi_templatek6z86r0w\",\"name\":\"Time Tagger\",\"group\":\"quTAG\",\"info\":\"游닆[0, 1, 2, 3, 4, 5] \",\"config\":\"\"}]","vi_templatejhrlp8yt":"{\"nodes\":[{\"x\":145,\"y\":157,\"fixed\":true,\"initial\":true,\"text\":\"stopped\",\"marked\":true},{\"x\":366,\"y\":164,\"fixed\":true,\"text\":\"started\",\"marked\":true,\"px\":366,\"py\":164},{\"x\":367,\"y\":321,\"weight\":1,\"fixed\":true,\"text\":\"Moving\",\"px\":367,\"py\":321},{\"x\":502,\"y\":319,\"weight\":1,\"fixed\":true,\"text\":\"repeat\",\"px\":502,\"py\":319},{\"x\":504,\"y\":489,\"weight\":1,\"fixed\":true,\"text\":\"Done\",\"px\":504,\"py\":489}],\"edges\":[{\"source\":0,\"target\":1,\"text\":\"10\"},{\"source\":1,\"target\":0,\"text\":\"8\"},{\"source\":1,\"target\":1,\"text\":\"10\"},{\"source\":1,\"target\":2,\"text\":\"102\"},{\"source\":2,\"target\":3,\"text\":\"102\"},{\"source\":2,\"target\":1,\"text\":\"103\"},{\"source\":0,\"target\":2,\"text\":\"102\"},{\"source\":3,\"target\":4,\"text\":\"102\"},{\"source\":3,\"target\":1,\"text\":\"103\"}],\"usercode\":\"CLOCK(c1)\\nINTEGER(X)\\nINTEGER(Y)\\nINTEGER(pixelnumber)\\nHISTOGRAM(t1, (`bins`, `binsize`), [`dimX`,`dimY`])\\n\\nMoving--103-->started:\\n    {\\n        pixelnumber+=1\\n        #print(X)\\n        #print(Y)\\n        x_counter_fwd = pixelnumber % `dimX`\\n        x_counter_bwd = `dimX`-x_counter_fwd-1\\n        Y = int(np.floor(pixelnumber / `dimX`))\\n        X = x_counter_fwd if Y%2 == 0 else x_counter_bwd\\n        conditional = int(pixelnumber == int(`dimX`)*int(`dimX`)+1)\\n    }\\n    \\nstopped:\\n    c1.stop()\\n    t1[X][Y].record(c1)\\n    \\nstarted:\\n    c1.start()\\n\\nrepeat:\\n    t1.clear()\\n\\nrepeat--103-->started:\\n    {\\n        print(\\\"Repeating the scan\\\")\\n        pixelnumber = 0\\n    }\\n    \\nDone:\\n    {\\n        print(\\\"It's done! It's over\\\")\\n    }\\n    abort()\"}","vi_templatejhrlupxy":"{\"nodes\":[{\"x\":141,\"y\":129,\"fixed\":true,\"initial\":true,\"text\":\"a\"}],\"edges\":[{\"source\":0,\"target\":0,\"text\":\"5\"}],\"usercode\":\"a:\\n    emit(10,`sync_delay`)# here, ch2 is duplicated to ch9 with a delay of bw_delay ps\"}","var_templatejkim2z6x":null,"var_templatejkim3bkj":null,"var_templatejkim48wp":null,"var_templatejkim6uch":null,"vi_templatejks7yt8a":"{\"nodes\":[{\"x\":141,\"y\":129,\"fixed\":true,\"initial\":true,\"text\":\"a\"}],\"edges\":[{\"source\":0,\"target\":0,\"text\":\"1\"}],\"usercode\":\"a:\\n    emit(8,`fw_delay`) # here, ch1 is duplicated to ch8 with a delay of fw_delay ps\"}","var_templatejks89alb":null,"var_templatek1wj6afv":null,"vi_templatek6z86r0w":"{\"nodes\":[{\"x\":135,\"y\":77,\"fixed\":true,\"initial\":true,\"px\":135,\"py\":77}],\"edges\":[],\"usercode\":\"RFILE(timetagger1,[0,1,2,3,4,5])\"}","var_templatek8k93yir":null,"var_templatek8k9432h":null,"var_templatek8k94746":null,"vi_templatekbz00gz5":"{\"nodes\":[{\"x\":145,\"y\":157,\"fixed\":true,\"initial\":true,\"text\":\"stopped\",\"marked\":true},{\"x\":366,\"y\":174,\"fixed\":true,\"text\":\"started\",\"marked\":true}],\"edges\":[{\"source\":0,\"target\":1,\"text\":\"5\"},{\"source\":1,\"target\":0,\"text\":\"9\"},{\"source\":1,\"target\":1,\"text\":\"5\"}],\"usercode\":\"CLOCK(c2)\\nHISTOGRAM(t2,(`bins`,`binsize`))\\n\\nstarted:\\n    c2.start()\\nstopped:\\n    c2.stop()\\n    t2.record(c2)\"}","vi_templatekbz03aiq":"{\"nodes\":[{\"x\":145,\"y\":157,\"fixed\":true,\"initial\":true,\"text\":\"stopped\",\"marked\":true},{\"x\":366,\"y\":174,\"fixed\":true,\"text\":\"started\",\"marked\":true}],\"edges\":[{\"source\":0,\"target\":1,\"text\":\"8\"},{\"source\":1,\"target\":0,\"text\":\"9\"},{\"source\":1,\"target\":1,\"text\":\"8\"}],\"usercode\":\"CLOCK(c3)\\nHISTOGRAM(t3,(`bins`,`binsize`))\\n\\nstarted:\\n    c3.start()\\nstopped:\\n    c3.stop()\\n    t3.record(c3)\"}","var_templatekippt2ni":null,"var_templatekipptn7c":null,"var_templatekippu799":null,"var_templatekiq1qw9x":null,"var_templatekir5s2pd":null,"vi_templatekkzm437v":"{\"nodes\":[{\"x\":141,\"y\":129,\"fixed\":true,\"initial\":true,\"text\":\"a\"}],\"edges\":[{\"source\":0,\"target\":0,\"text\":\"2\"}],\"usercode\":\"a:\\n    emit(9,`bw_delay`)# here, ch2 is duplicated to ch9 with a delay of bw_delay ps\"}","var_templatekl80ywey":null,"var_templateklgftl3g":null,"var_templatekrm0koas":null}